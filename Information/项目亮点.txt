《uwsgi服务器》
高性能低延迟：
    内部架构 是优化过的、内部设有缓存机制
    事件模型-异步io/多线程处理
    协议基于二进制-减少数据传输大小
    多种部署方式


《protobuf通信协议》
用于实现事件分发机制
提高数据传输效率
    缺点：
    基于二进制传输（既是优点又是缺点），相对于JSON信息不可读




《redis高可用的实现》
主从同步、等

《※ 数据不一致问题的分析》
缓存数据库更新的 四种策略：
    1\先更新mysql 再更新redis：不适用于写多读少的场景，高并发场景有线程安全的问题
    2\先更新redis 再更新mysql：高并发场景有线程安全的问题；响应速度快。
    3\先删除redis 再更新mysql：实现简单，能够避免某个线程读取缓存中的旧数据；
        操作数据库时脏数据导致缓存长期不一致问题；解决方案：延时双删
    4\先更新mysql 再删除redis：减少数据不一致的时间窗口.避免缓存击穿的问题。
    

《※ 缓存的三种异常》
缓存雪崩：缓存中有大量地数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机
    解决方案：
    1、永不过期：如果是热点数据，那么可以考虑设置永远不过期
    2、波动随机值：在理论时间上随机延长一段时间，避免大量数据同时失效
    3、双缓存：数据库数据同步到缓存A和B，A设置过期时间、B不设置过期时间，如果A空了的时候，去读取B，同时异步去更新缓存，但是更新时需要同时更新两个缓存
    4、熔断机制：如果大量请求访问空缓存，直接返回redis服务器正忙，避免大量请求
    5、redis集群分散数据：将热点数据打散分布到不同的redis服务器上   

缓存穿透：数据库原本有的数据，缓存中没有，一般是缓存突然失效了，此时，大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。
    解决方案：
    1、如果是热点数据、设置永不过期
    2、如果数据注定要过期，那么就需要在数据库为空的时候，设置一个互斥锁，只让一个请求通过，只有一个请求去数据库拉去数据，取完数据，不管如何都要释放锁，异常的时候也要释放锁，不然其它线程会一直拿不到锁。
    3、在2的基础上，可以设置一个阈值，比如等待5次，每次1s，达到这个阈值时，直接返回空，不应该过度消耗机器

缓存击穿：缓存和数据库都没有数据，被大量请求，比如订单号不可能为-1，但是有些可恶的人非法的模拟请求了大量的订单号为-1的数据，由于数据不存在，缓存也不会存在该数据，所有的请求都会被直接穿透到数据库。所以穿透的意思是，哪一层缓存都没有，直接一路打到了数据库。
    解决问题：
    1、接口增加业务层级的Filter（过滤器），进行合法校验，这样就可以有效拦截大部分不合法的请求
    2、作为第一点的补充，最常见的是使用布隆过滤器，针对一个或多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也是可能存在，因为不同的数值hash到bit位很可能是一样的，hash冲突可能导致误判，多个hash方法也只能降低冲突概率，无法做到避免，
    3、另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内，而这种数据，如果数据库有写入或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。


《redis在本项目的应用》
    作为缓存中间件存储热点数据
    关系型数据库 - 非关系型数据库：
        数据模型：结构化数据-数据类型与约束；非结构化数据-没有固定的数据格式；（JSON/XML等是半结构化数据格式）
        事务处理：关系型-数据的强一致性，用于: 银行转账；非关系型-没有强一致性，不回滚
        扩展性：关系型扩展性差-需要维护表；非关系型扩展性好-只需要增加结点就可以了
        性能：非关系型数据库直接读写效率高；关系型数据库的复杂查询更加优秀
    缓存可能出现的问题：缓存雪崩、缓存穿透、缓存击穿



《登录状态检测》
    内置的session -缓存一致性问题
    （服务器集群中）
    中间件redis存储键值对、redis存储session


《数据库连接池优化连接》-怎么用，目的，性能提升多少等等

《数据批量操作提升效率》
        -execute()
            每次发送一条请求
        -executemany()
            用于执行多次 SQL语句相同 但参数不同 的命令。执行批量操作，如大量数据插入。
            通过一次性发送多条记录，减少网络开销和数据库交互次数，从而提高资源利用率。

《sql注入问题》
        是一种常见的网络攻击方式，攻击者通过在应用程序的输入字段中插入恶意的SQL代码，
        试图非法访问、操作或破坏后端数据库。
        当应用程序不正确地处理用户输入，并将其直接拼接到SQL查询中时，就可能发生这种攻击

        如果sql语句带参数，尽量不要使用%s和format进行字符串拼接，以此防止sql注入
        如果fromat中的替换字符串为客户端传入参数，那么就会发生sql注入，继而查询出所有用户信息
        解决方法：参数化查询
            sqlStr = "select * from user where userid = %s"
            cursor,execute(sqlStr,(userid,))

《Webpy框架以及在Python中的使用》

《WSGI协议及在python中的使用》